==========
Simulation
==========

.. toctree::
   :hidden:
   :glob:
   
   install
   bootstraps
   signal
   clock
   threadFull
   threadLess
   sensitive
   engine
   examples/index

.. role:: raw-html-m2r(raw)
   :format: html


Introduction
------------

As always, you can use your standard simulation tools to simulate the VHDL/Verilog files generated by SpinalHDL, but since SpinalHDL 1.0.0 the language integrates an API that allows you to write testbenches and test your hardware directly in Scala.

The simulation API provides the capabilities to:

* Read and write the :abbr:`DUT (Device Under Test)`'s signals
* Fork and join simulation processes
* Sleep and wait until a given condition is filled

How does SpinalHDL simulate the hardware?
-----------------------------------------

Behind the scenes, SpinalHDL generates a C++ cycle-accurate model of your hardware by generating the equivalent Verilog, and then using Verilator to convert it into a C++ model.

Then SpinalHDL uses GCC to compile the C++ model into a shared object (.so) file, and binds it back to Scala via `JNI <https://en.wikipedia.org/wiki/Java_Native_Interface>`_.

Finally, as the native Verilator API is rather crude, SpinalHDL abstracts over it by providing both single and multi-threaded simulation APIs to help the user construct testbench implementations.

This simulation methodology has several advantages:

* The C++ simulation model processes simulation steps very quickly
* It tests the generated Verilog hardware instead of the SpinalHDL internal model
* It doesn't require SpinalHDL to be able to simulate the hardware itself (This keeps the codebase smaller, and reduces bugs, since Verilator is a reliable tool)

However, there are some limitations:

* Verilator will only accept synthesizable Verilog code

Performance
-----------

As Verilator is the current simulation backend, the simulation speed is very fast.

On a small SoC like `Murax <https://github.com/SpinalHDL/VexRiscv>`_ a modern laptop can simulate 1.2 million clock cycles or more, per realtime second.

